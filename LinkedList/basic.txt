参考资料：https://lucifer.ren/blog/2020/11/08/linked-list/

数组：连续的存储单元，因此可以直接通过下标随机访问
链表：不连续的存储单元，一般是通过next指针进行遍历访问

简单来说”数组对查询特别友好，对删除和添加不友好“。为了解决这个问题，就有了链表这种数据结构。不必要求物理内存的连续性，以及对插入和删除的友好

1.链表由一系列结点组成，结点可以在运行时动态一个节点存储两个信息，分别是数据和指针。
2.链表只有一个后驱节点 next，如果是双向链表还会有一个前驱节点 pre。
3.有没有想过为啥只有二叉树，而没有一叉树。实际上链表就是特殊的树，即一叉树。

【链表的基本操作】时刻注意考虑头尾指针的情况
（1）插入：只需考虑插入元素的前驱节点和后继节点（双向链表要考虑后继）即可，其他节点不受影响。因此，在给定指针的情况下，插入操作的时间复杂度是O(1)；没有给定指针的情况下，需要先遍历找到对应的结点，然后再插入，最坏情况下时间复杂度是O(N)。
伪代码：假设待插入指针为x,前驱结点是pre
        temp=pre.next #temp先存储前驱结点pre的下一个结点
        pre.next=x #现在pre的下一个结点换成x
        x.next=temp #之前pre的下一个结点变成x的下一位
（2）删除：将需要删除的结点的前驱结点指针的next修改为它的下下个节点即可（即跳过被删除的节点），注意考虑边界条件。
伪代码：假设待删除的节点是x，x的前驱节点是pre
        pre.next=pre.next.next
（3）遍历链表：
伪代码：当前指针为cur，头指针为root
        cur=root
        while cur:
            print(cur.val)
            cur=cur.next
（4）构建链表：见代码文件createLinkedList.py
            

